/*

setInterval
  定时器的累计效应
  定时器代码执行之间的间隔可能比预期的要小
  定时器某些间隔被跳过
  setInterval如果上一个回调函数没有被执行，它是不会被注册


setTimeout
  默认最低延时
  设置一个延时器，该定时器在指定时间到期后执行一个函数或者一段代码
  真正的执行是在时间循环中执行，真正的执行时间大于最小的延时时间
  最低时延为1ms



requestAnimationFrame(raf)
  事件循环执行机制
  告诉浏览器，你想要一个动画帧，并且要求浏览器在下次重绘之前执行指定的回调函数更新动画
  回调函数执行次数与浏览器屏幕的刷新频率相关，比如每秒60次，每帧60次
  事件循环步骤：一个宏任务->所有的微任务-->是否需要渲染->渲染UI
  在事件循环中，requestAnimationFrame实际上就是在UI渲染中执行的
  对比setTimeout，requestAnimationFrame的延时时间更小，但是更高效;由系统决定回调函数的执行诗句

  优点：
    dom操作与浏览器的刷新频率保持一致，保持动画流畅
    在隐藏或不可见的元素中，RAF将不进行重绘与回流，节省cpu资源,页面不是激活状态，动画会自动暂停
  注意：
    如果事件循环有任务耗时特别长，RAF的动画效果大打折扣


requestIdleCallback
  在浏览器空闲的时候调用函数排队
  参数：
    callback: 事件空闲时被调用函数的引用
    options: timeout: 超时时间，为正值，超时没执行，放到下次的事件循环中排队执行
  空闲时间的计算
    连续持续渲染的两帧，空闲时间就是帧的频率减去执行任务的时间，减去绘制的时间
    16.7 - 宏任务 - 微任务 - 微任务 - 渲染的时间
    当一段时间没有绘制或者任务是，空闲时间最大不超过50ms
  
    一般用来执行优先级比较低的任务
    如果空闲时间不足，则会放到下次的事件循环中排队执行
*/